#!/usr/bin/env python3
import argparse
from pathlib import Path
from typing import List, Tuple

import cv2
import numpy as np
import torch
from scipy.ndimage import binary_dilation
from skimage.segmentation import find_boundaries


DEFAULT_PAIRS = (
    "hifigan_LA_D_5495040:12;"
    "hn-sinc-nsf-hifi_LA_D_5621016:3;"
    "hn-sinc-nsf_LA_D_3205943:2;"
    "waveglow_LA_D_1469404:5"
)


def parse_args():
    parser = argparse.ArgumentParser(
        description="Batch-highlight selected region IDs for selected sample IDs."
    )
    parser.add_argument(
        "--pairs",
        default=DEFAULT_PAIRS,
        help="Semicolon-separated sample_id:region_id pairs.",
    )
    parser.add_argument(
        "--image-root",
        default="/datasets/work/dss-deepfake-audio/work/data/datasets/interspeech/img/specs/grid",
        help="Root containing spectrogram images.",
    )
    parser.add_argument(
        "--masks-root",
        required=True,
        help="Root containing *_masks.pth generated by region_division.py.",
    )
    parser.add_argument(
        "--method-contains",
        default="",
        help="Optional substring to prefer a method in mask filename (e.g., superpixel_n60_c20.0 or grid).",
    )
    parser.add_argument(
        "--output-dir",
        required=True,
        help="Where to save highlighted PNGs.",
    )
    parser.add_argument("--thickness", type=int, default=5, help="Boundary thickness in pixels.")
    parser.add_argument("--color", default="255,0,0", help="Boundary RGB color as R,G,B.")
    parser.add_argument(
        "--prefer-axes-image",
        action="store_true",
        default=False,
        help="Prefer *_axes.png and project mask boundary onto the plotted spectrogram area.",
    )
    return parser.parse_args()


def parse_pairs(pairs_str: str) -> List[Tuple[str, int]]:
    out = []
    for part in pairs_str.split(";"):
        part = part.strip()
        if not part:
            continue
        if ":" not in part:
            raise ValueError(f"Invalid pair '{part}'. Expected sample_id:region_id")
        sid, rid = part.split(":", 1)
        sid = sid.strip()
        rid = int(rid.strip())
        if rid < 1:
            raise ValueError(f"region_id must be >=1 for {sid}")
        out.append((sid, rid))
    if not out:
        raise ValueError("No valid pairs parsed from --pairs")
    return out


def parse_color(color_str: str):
    parts = [p.strip() for p in color_str.split(",")]
    if len(parts) != 3:
        raise ValueError("--color must be R,G,B")
    vals = tuple(int(x) for x in parts)
    for v in vals:
        if v < 0 or v > 255:
            raise ValueError("Color channels must be in [0,255]")
    return vals


def find_image(image_root: Path, sample_id: str) -> Path:
    # Prefer non-axes by default because masks are generated on that canvas.
    patterns = [
        f"{sample_id}_grid_img_edge_number.png",
        f"{sample_id}_grid_img_edge_number_axes.png",
        f"{sample_id}.png",
    ]
    for pat in patterns:
        matches = sorted(image_root.rglob(pat))
        if matches:
            return matches[0]
    raise FileNotFoundError(f"No image found for sample_id={sample_id} under {image_root}")


def find_image_axes_first(image_root: Path, sample_id: str) -> Path:
    patterns = [
        f"{sample_id}_grid_img_edge_number_axes.png",
        f"{sample_id}_grid_img_edge_number.png",
        f"{sample_id}.png",
    ]
    for pat in patterns:
        matches = sorted(image_root.rglob(pat))
        if matches:
            return matches[0]
    raise FileNotFoundError(f"No image found for sample_id={sample_id} under {image_root}")


def find_masks(masks_root: Path, sample_id: str, method_contains: str) -> Path:
    matches = sorted(masks_root.rglob(f"{sample_id}_*_masks.pth"))
    if not matches:
        raise FileNotFoundError(f"No *_masks.pth found for sample_id={sample_id} under {masks_root}")
    if method_contains:
        filt = [m for m in matches if method_contains in m.name]
        if filt:
            return filt[0]
    return matches[0]


def load_mask(masks_path: Path, region_id: int) -> np.ndarray:
    # PyTorch 2.6+ defaults to weights_only=True, which breaks loading
    # region_division.py mask dicts containing numpy objects.
    obj = torch.load(masks_path, map_location="cpu", weights_only=False)
    masks = obj.get("masks", None) if isinstance(obj, dict) else None
    if not isinstance(masks, (list, tuple)):
        raise ValueError(f"Invalid masks file: {masks_path}")
    idx = region_id - 1
    if idx >= len(masks):
        raise IndexError(f"region_id={region_id} out of range for {masks_path.name}; max={len(masks)}")
    return np.asarray(masks[idx]).astype(bool)


def draw_boundary(rgb: np.ndarray, mask: np.ndarray, color_rgb, thickness: int) -> np.ndarray:
    boundary = find_boundaries(mask, mode="inner")
    if thickness > 1:
        boundary = binary_dilation(boundary, iterations=thickness - 1)
    out = rgb.copy()
    out[boundary] = np.array(color_rgb, dtype=np.uint8)
    return out


def draw_boundary_on_axes_image(rgb_axes: np.ndarray, mask: np.ndarray, color_rgb, thickness: int) -> np.ndarray:
    """
    Project boundary from 768x768-ish mask to *_axes.png canvas created by region_division.py:
      fig.subplots_adjust(left=0.16, right=0.98, bottom=0.13, top=0.98)
      ax.imshow(np.flipud(rgb_img), ...)
    """
    h, w = rgb_axes.shape[:2]
    x0 = int(round(0.16 * w))
    x1 = int(round(0.98 * w))
    y0 = int(round(0.13 * h))
    y1 = int(round(0.98 * h))
    x0 = max(0, min(x0, w - 1))
    x1 = max(x0 + 1, min(x1, w))
    y0 = max(0, min(y0, h - 1))
    y1 = max(y0 + 1, min(y1, h))

    boundary = find_boundaries(mask, mode="inner")
    if thickness > 1:
        boundary = binary_dilation(boundary, iterations=thickness - 1)

    # Axes image displays np.flipud(rgb_img), so flip mask vertically to align.
    boundary = np.flipud(boundary).astype(np.uint8) * 255
    roi_w = x1 - x0
    roi_h = y1 - y0
    boundary_resized = cv2.resize(boundary, (roi_w, roi_h), interpolation=cv2.INTER_NEAREST) > 0

    out = rgb_axes.copy()
    roi = out[y0:y1, x0:x1]
    roi[boundary_resized] = np.array(color_rgb, dtype=np.uint8)
    out[y0:y1, x0:x1] = roi
    return out


def main():
    args = parse_args()
    pairs = parse_pairs(args.pairs)
    color_rgb = parse_color(args.color)
    image_root = Path(args.image_root).expanduser().resolve()
    masks_root = Path(args.masks_root).expanduser().resolve()
    out_root = Path(args.output_dir).expanduser().resolve()
    out_root.mkdir(parents=True, exist_ok=True)

    for sample_id, region_id in pairs:
        image_path = (
            find_image_axes_first(image_root, sample_id)
            if args.prefer_axes_image
            else find_image(image_root, sample_id)
        )
        masks_path = find_masks(masks_root, sample_id, args.method_contains)

        bgr = cv2.imread(str(image_path), cv2.IMREAD_COLOR)
        if bgr is None:
            raise ValueError(f"Failed to read image: {image_path}")
        rgb = cv2.cvtColor(bgr, cv2.COLOR_BGR2RGB)

        mask = load_mask(masks_path, region_id)
        if mask.shape[:2] == rgb.shape[:2]:
            highlighted = draw_boundary(rgb, mask, color_rgb, args.thickness)
        else:
            # Typical case for *_axes.png: project onto plot area instead of failing.
            highlighted = draw_boundary_on_axes_image(rgb, mask, color_rgb, args.thickness)
        out_path = out_root / f"{sample_id}_region{region_id}_highlight.png"
        cv2.imwrite(str(out_path), cv2.cvtColor(highlighted, cv2.COLOR_RGB2BGR))
        print(out_path.as_posix())


if __name__ == "__main__":
    main()
